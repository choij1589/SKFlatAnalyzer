#include "MeasFakeRateV5.h"

MeasFakeRateV5::MeasFakeRateV5() {}
MeasFakeRateV5::~MeasFakeRateV5() {
    delete hNPVData;
    delete hNPVMC;
}

void MeasFakeRateV5::initializeAnalyzer() {
    // Userflags
    MeasFakeMu8 = HasFlag("MeasFakeMu8");
    MeasFakeMu17 = HasFlag("MeasFakeMu17");
    //MeasFakeEl8 = HasFlag("MeasFakeEl8");
    MeasFakeEl12 = HasFlag("MeasFakeEl12");
    MeasFakeEl23 = HasFlag("MeasFakeEl23");
    MeasFakeMu = MeasFakeMu8 || MeasFakeMu17;
    MeasFakeEl = MeasFakeEl12 || MeasFakeEl23;
    RunSyst = HasFlag("RunSyst");
    RunSystSimple = HasFlag("RunSystSimple"); // Only check the effect of the selection variations
    
    // Era dependent settings
    if (DataEra == "2016preVFP") {
        MuonIDs->SetIDs("HcToWATight", "HcToWALoose", "HcToWAVeto");
        ElectronIDs->SetIDs("HcToWATight16a", "HcToWALoose16a", "HcToWAVeto16a");
    } else if (DataEra == "2016postVFP") {
        MuonIDs->SetIDs("HcToWATight", "HcToWALoose", "HcToWAVeto");
        ElectronIDs->SetIDs("HcToWATight16b", "HcToWALoose16b", "HcToWAVeto16b");
    } else if (DataEra == "2017") {
        MuonIDs->SetIDs("HcToWATight", "HcToWALoose", "HcToWAVeto");
        ElectronIDs->SetIDs("HcToWATight17", "HcToWALoose17", "HcToWAVeto17");
    } else if (DataEra == "2018") {
        MuonIDs->SetIDs("HcToWATight", "HcToWALoose", "HcToWAVeto");
        ElectronIDs->SetIDs("HcToWATight18", "HcToWALoose18", "HcToWAVeto18");
    } else {
        cerr << "[MeasFakeRateV5::initializeAnalzyer] Wrong era " << DataEra << endl;
        exit(EXIT_FAILURE);
    }

    // Trigger Settings
    if (MeasFakeMu8) {
        isoSglLepTrig = "HLT_Mu8_TrkIsoVVL_v";
        trigSafePtCut = 10.;
    } else if (MeasFakeMu17) {
        isoSglLepTrig = "HLT_Mu17_TrkIsoVVL_v";
        trigSafePtCut = 20.;
    } else if (MeasFakeEl12) {
        isoSglLepTrig = "HLT_Ele12_CaloIdL_TrackIdL_IsoVL_PFJet30_v";
        trigSafePtCut = 15.;
    } else if (MeasFakeEl23) {
        isoSglLepTrig = "HLT_Ele23_CaloIdL_TrackIdL_IsoVL_PFJet30_v";
        trigSafePtCut = 25.;
    } else {
        cerr << "[MeasFakeRateV5::initializeAnalyzer] No trigger specified by userflags" << endl;
        exit(EXIT_FAILURE);
    }
    
    // Jet Tagger
    vector<JetTagging::Parameters> jtps;
    jtps.emplace_back(JetTagging::Parameters(JetTagging::DeepJet, JetTagging::Medium, JetTagging::incl, JetTagging::mujets));
    mcCorr->SetJetTaggingParameters(jtps);

    // Systematics
    weightVariations = {"Central"};
    scaleVariations = {};
    selectionVariations = {};
    
    if (RunSystSimple) {
        selectionVariations = {"MotherJetPtUp", "MotherJetPtDown", "RequireHeavyTag"};
    } else if (RunSyst) {
        if (MeasFakeMu && !IsDATA) {
            weightVariations = {"Central", 
                                "PileupReweight",
                                "L1PrefireUp", "L1PrefireDown",
                                "MuonRecoSFUp", "MuonRecoSFDown"};
        }
        if (MeasFakeEl && !IsDATA) {
            weightVariations = {"Central", 
                                "PileupReweight",
                                "L1PrefireUp", "L1PrefireDown",
                                "ElectronRecoSFUp", "ElectronRecoSFDown"};
        }
        scaleVariations = {"JetResUp", "JetResDown",
                           "JetEnUp", "JetEnDown",
                           "MuonEnUp", "MuonEnDown",
                           "ElectronEnUp", "ElectronEnDown",
                           "ElectronResUp", "ElectronResDown"};
        selectionVariations = {"MotherJetPtUp", "MotherJetPtDown", "RequireHeavyTag"};
    }

    if (IsDATA) {
        systematics = {"Central"};
        systematics.insert(systematics.end(), scaleVariations.begin(), scaleVariations.end());
        systematics.insert(systematics.end(), selectionVariations.begin(), selectionVariations.end());
    } else {
        systematics = weightVariations;
        systematics.insert(systematics.end(), scaleVariations.begin(), scaleVariations.end());
        systematics.insert(systematics.end(), selectionVariations.begin(), selectionVariations.end());
    }
    
    // link histograms
    TString PUPath = TString(getenv("DATA_DIR")) + "/" + GetEra() + "/PileUp";
    TFile *fNPVData, *fNPVMC;
    if (MeasFakeMu8) {
        fNPVData = new TFile(PUPath+"/NPVMuon_DATA.root");
        fNPVMC   = new TFile(PUPath+"/NPVMuon_MC.root");
        hNPVData = (TH1D*)fNPVData->Get("Inclusive_Mu8/loose/central/nPV"); hNPVData->SetDirectory(0);
        hNPVMC = (TH1D*)fNPVMC->Get("Inclusive_Mu8/loose/central/nPV"); hNPVMC->SetDirectory(0);
    } else if (MeasFakeMu17) {
        fNPVData = new TFile(PUPath+"/NPVMuon_DATA.root");
        fNPVMC   = new TFile(PUPath+"/NPVMuon_MC.root");
        hNPVData = (TH1D*)fNPVData->Get("Inclusive_Mu17/loose/central/nPV"); hNPVData->SetDirectory(0);
        hNPVMC = (TH1D*)fNPVMC->Get("Inclusive_Mu17/loose/central/nPV"); hNPVMC->SetDirectory(0);
    } else if (MeasFakeEl12) {
        fNPVData = new TFile(PUPath+"/NPVElectron_DATA.root");
        fNPVMC   = new TFile(PUPath+"/NPVElectron_MC.root");
        hNPVData = (TH1D*)fNPVData->Get("Inclusive_Ele12/loose/central/nPV"); hNPVData->SetDirectory(0);
        hNPVMC = (TH1D*)fNPVMC->Get("Inclusive_Ele12/loose/central/nPV"); hNPVMC->SetDirectory(0);
    } else if (MeasFakeEl23) {
        fNPVData = new TFile(PUPath+"/NPVElectron_DATA.root");
        fNPVMC   = new TFile(PUPath+"/NPVElectron_MC.root");
        hNPVData = (TH1D*)fNPVData->Get("Inclusive_Ele23/loose/central/nPV"); hNPVData->SetDirectory(0);
        hNPVMC = (TH1D*)fNPVMC->Get("Inclusive_Ele23/loose/central/nPV"); hNPVMC->SetDirectory(0);
    } else {
        cerr << "[MeasFakeRateV5::initializeAnalyzer] No path specified by userflags" << endl;
        exit(EXIT_FAILURE);
    }
    fNPVData->Close();
    fNPVMC->Close();

    // scale histograms
    hNPVData->Scale(1./hNPVData->Integral());
    hNPVMC->Scale(1./hNPVMC->Integral());
}

void MeasFakeRateV5::executeEvent() {
    rawMuons = GetAllMuons();
    rawElectrons = GetAllElectrons();
    rawJets = GetAllJets();
    truth = GetGens();

    // Central Scale - includes central values of scales and weights
    NonpromptParameter param;
    // loop over weight variations
    // No need to reapply the cuts for the weight variations
    // will loop over the weight variation in executeEventWith(param)
    param.Clear();
    param.SetName("Central");
    param.SetScale("Central");
    param.SetSyst("Central");
    param.SetSelection("Central");
    executeEventWith(param);

    // Scale Variations
    for (const auto &scale: scaleVariations) {
        param.Clear();
        param.SetName(scale);
        param.SetScale(scale);
        param.SetSyst("Central");
        param.SetSelection("Central");
        executeEventWith(param);
    }

    // Selection Variations
    for (const auto &selection: selectionVariations) {
        param.Clear();
        param.SetName(selection);
        param.SetScale("Central");
        param.SetSyst("Central");
        param.SetSelection(selection);
        executeEventWith(param);
    }
}

void MeasFakeRateV5::executeEventWith(NonpromptParameter &param) {
    if (!PassMETFilter()) return;
    Event ev = GetEvent();
    Particle METv = ev.GetMETVector();
    if (! ev.PassTrigger(isoSglLepTrig)) return;

    // start of object definition
    vector<Muon> allMuons = rawMuons;
    vector<Electron> allElectrons = rawElectrons;
    vector<Jet> allJets = rawJets;

    // apply scale variations
    if (param.GetScale() == "Central") {
        // do nothing
    } else if (param.GetScale() == "MuonEnUp") {
        allMuons = ScaleMuons(allMuons, 1);
    } else if (param.GetScale() == "MuonEnDown") {
        allMuons = ScaleMuons(allMuons, -1);
    } else if (param.GetScale() == "ElectronEnUp") {
        allElectrons = ScaleElectrons(allElectrons, 1);
    } else if (param.GetScale() == "ElectronEnDown") {
        allElectrons = ScaleElectrons(allElectrons, -1);
    } else if (param.GetScale() == "ElectronResUp") {
        allElectrons = SmearElectrons(allElectrons, 1);
    } else if (param.GetScale() == "ElectronResDown") {
        allElectrons = SmearElectrons(allElectrons, -1);
    } else if (param.GetScale() == "JetEnUp") {
        allJets = ScaleJets(allJets, 1);
    } else if (param.GetScale() == "JetEnDown") {
        allJets = ScaleJets(allJets, -1);
    } else if (param.GetScale() == "JetResUp") {
        allJets = SmearJets(allJets, 1);
    } else if (param.GetScale() == "JetResDown") {
        allJets = SmearJets(allJets, -1);
    } else {
        cerr << "[MeasFakeRateV5::executeEventWith] Wrong scale variation " << param.GetScale() << endl;
        exit(EXIT_FAILURE);
    }

    // select objects
    vector<Muon> vetoMuons = SelectMuons(allMuons, MuonIDs->GetVetoID(), 10., 2.4);
    vector<Muon> looseMuons = SelectMuons(allMuons, MuonIDs->GetLooseID(), 10., 2.4);
    vector<Muon> tightMuons = SelectMuons(allMuons, MuonIDs->GetTightID(), 10., 2.4);
    vector<Electron> vetoElectrons = SelectElectrons(allElectrons, ElectronIDs->GetVetoID(), 10., 2.5);
    vector<Electron> looseElectrons = SelectElectrons(allElectrons, ElectronIDs->GetLooseID(), 10., 2.5);
    vector<Electron> tightElectrons = SelectElectrons(allElectrons, ElectronIDs->GetTightID(), 10., 2.5);

    // apply selection variations to jet pt cut
    double jetPtCut = 0.;
    if (param.GetSelection() == "MotherJetPtUp") {
        jetPtCut = 50.;
    } else if (param.GetSelection() == "MotherJetPtDown") {
        jetPtCut = 30.;
    } else {
        jetPtCut = 40.;
    }
    vector<Jet> tmpjets = SelectJets(allJets, "tight", jetPtCut, 2.4);
    tmpjets = JetsVetoLeptonInside(tmpjets, vetoElectrons, vetoMuons, 0.4);
    vector<Jet> jets, bjets;
    for (const auto &jet: tmpjets) {
        const double btagScore = jet.GetTaggerResult(JetTagging::DeepJet);
        if (btagScore > mcCorr->GetJetTaggingCutValue(JetTagging::DeepJet, JetTagging::Medium)) {
            bjets.push_back(jet);
        }
    }
    if (param.GetSelection() == "RequireHeavyTag") {
        jets = bjets;
    } else {
        jets = tmpjets;
    }
    // end of object definition
    // end of scale and selection variations

    // start event selection
    const bool SglMu = (looseMuons.size() == 1 && vetoMuons.size() == 1 && looseElectrons.size() == 0 && vetoElectrons.size() == 0);
    const bool SglEl = (looseElectrons.size() == 1 && vetoElectrons.size() == 1 && looseMuons.size() == 0 && vetoMuons.size() == 0);
    const bool DblMu = (looseMuons.size() == 2 && vetoMuons.size() == 2 && looseElectrons.size() == 0 && vetoElectrons.size() == 0);
    const bool DblEl = (looseElectrons.size() == 2 && vetoElectrons.size() == 2 && looseMuons.size() == 0 && vetoMuons.size() == 0);
    TString channel = "";
    if (MeasFakeMu) {
        if (! (SglMu || DblMu)) return;
        if (! (looseMuons.at(0).Pt() > trigSafePtCut)) return;
        if (! (jets.size() == 1)) return;
        if (! (jets.at(0).DeltaR(looseMuons.at(0)) > 1.)) return;
        const double mt = MT(looseMuons.at(0), METv);
        const double met = METv.Pt();
        const bool isQCD = (mt < 25. && met < 25.);
        const bool isW = (mt > 50. && met > 50.);
        // Define channels
        if (SglMu) {
            if (MCSample.Contains("QCD") || isQCD) channel = "QCDEnriched";
            if (isW) channel = "WEnriched";
        } else if (DblMu) {
            const Particle ZCand = looseMuons.at(0) + looseMuons.at(1);
            const bool isOnZ = (fabs(ZCand.M() - 91.2) < 15.);
            if (! isOnZ) return;
            channel = "ZEnriched";
        } else {
            return;
        }
    } else if (MeasFakeEl) {
        if (! (SglEl || DblEl)) return;
        if (! (looseElectrons.at(0).Pt() > trigSafePtCut)) return;
        if (! (jets.size() == 1)) return;
        if (! (jets.at(0).DeltaR(looseElectrons.at(0)) > 1.)) return;
        const double mt = MT(looseElectrons.at(0), METv);
        const double met = METv.Pt();
        const bool isQCD = (mt < 25. && met < 25.);
        const bool isW = (mt > 50. && met > 50.);
        // Define channels
        if (SglEl) {
            if (MCSample.Contains("QCD") || isQCD) channel = "QCDEnriched";
            if (isW) channel = "WEnriched";
        } else if (DblEl) {
            const Particle ZCand = looseElectrons.at(0) + looseElectrons.at(1);
            const bool isOnZ = (60. < ZCand.M() && ZCand.M() < 120.);
            if (! isOnZ) return;
            channel = "ZEnriched";
        } else {
            return;
        }
    } else {
        cerr << "[MeasFakeRateV5::executeEventWith] No lepton specified by userflags" << endl;
        exit(EXIT_FAILURE);
    }
    // NOTE: Now SglMu and SglEl are mutually exclusive by MT and MET cut
    //       But there is no requirement wiht MT and MET cut to return the event
    //       These events are to see the effectiveness of the MT and MET cut
    //       which will be categorized as "Inclusive" channel
    // End of event selection
    
    // Logic is the same up to this point
    // get weights with different systematic sources
    // First fill objects with the central weight
    // Scale and Selection variations are already applied
    double weight = getEventWeight(param, ev, looseMuons, looseElectrons, tmpjets);
    if (SglMu) {
        double ptcorr_edges[] = {10., 15., 20., 30., 50., 100., 200.};
        double abseta_edges[] = {0., 0.9, 1.6, 2.4};
        const int nptcorr = sizeof(ptcorr_edges)/sizeof(double);
        const int nabseta = sizeof(abseta_edges)/sizeof(double);
        const Muon &mu = muons.at(0);
        const Particle METv = ev.GetMETVector();
        const double mT = MT(mu, METv);
        const double ptcorr = mu.Pt()*(1.+max(0, mu.MiniRelIso()-0.1));
        const double abseta = fabs(mu.Eta());
        const TString prefix = FindBin(ptcorr, abseta, ptcorr_edges, nptcorr, abseta_edges, nabseta);
    }

    //FillObjects(channel, ev, looseMuons, looseElectrons, tmpjets, weight);
    
    /*
    for (const auto &syst: weightVariations) {
        if (! (param.GetScale() == "Central" || param.GetSelection() == "Central")) continue;
        param.SetSyst(syst);
        double weight = getEventWeight(param, ev, looseMuons, looseElectrons, tmpjets);
         
    }
    */
}

double MeasFakeRateV5::getEventWeight(const NonpromptParameter &param, Event &ev, vector<Muon> &muons, vector<Electron> &electrons, vector<Jet> &jets) {
    double weight = 1.;
    if (!IsDATA) {
        weight = MCweight()*ev.GetTriggerLumi("Full");
        // L1 Prefire
        if (param.GetSyst() == "L1PrefireUp") {
            weight *= GetPrefireWeight(1);
        } else if (param.GetSyst() == "L1PrefireDown") {
            weight *= GetPrefireWeight(-1);
        } else {
            weight *= GetPrefireWeight(0);
        }

        // Top PT reweight
        if (MCSample.Contains("TTLL") || MCSample.Contains("TTLJ")) {
            weight *= mcCorr->GetTopPtReweight(truth);
        }

        // Only apply lepton reco scale factor
        for (const auto &mu: muons) {
            if (param.GetSyst() == "MuonRecoSFUp") {
                weight *= mcCorr->MuonReco_SF(mu.Eta(), 1);
            } else if (param.GetSyst() == "MuonRecoSFDown") {
                weight *= mcCorr->MuonReco_SF(mu.Eta(), -1);
            } else {
                weight *= mcCorr->MuonReco_SF(mu.Eta(), 0);
            }
        }
        for (const auto &el: electrons) {
            if (param.GetSyst() == "ElectronRecoSFUp") {
                weight *= mcCorr->ElectronReco_SF(el.scEta(), el.Pt(), 1);
            } else if (param.GetSyst() == "ElectronRecoSFDown") {
                weight *= mcCorr->ElectronReco_SF(el.scEta(), el.Pt(),-1);
            } else {
                weight *= mcCorr->ElectronReco_SF(el.scEta(), el.Pt(), 0);
            }
        }

        // nPV reweight
        if (param.GetSyst() == "PileupReweight") {
            weight *= GetPileUpWeight(nPileUp, 0);
        } else {
            weight *= getNPVReweight(nPV);
        }
        if (param.GetSelection() == "RequireHeavyTag") {
            JetTagging::Parameters jtp = JetTagging::Parameters(JetTagging::DeepJet,
                                                                JetTagging::Medium,
                                                                JetTagging::incl,
                                                                JetTagging::mujets);
            weight *= mcCorr->GetBTaggingReweight_1a(jets, jtp);
        }
    }
    return weight;
}


double MeasFakeRateV5::getNPVReweight(const unsigned int nPV) {
    const double nPVcorr = max(1, min(int(nPV), 69));
    const unsigned int thisBin = hNPVData->FindBin(nPVcorr);
    // for 2016a and 2016b, some bins (nPV > 60) are empty...
    // almost no event would be affected by this bins, just apply 1
    if (hNPVMC->GetBinContent(thisBin) == 0) {
        return 1.;
    } else {
        return hNPVData->GetBinContent(thisBin) / hNPVMC->GetBinContent(thisBin);
    }
}
/*
void MeasFakeRateV5::FillObjects(const TString &channel, const Event &ev, const vector<Muon> &muons, const vector<Jet> &jets, const double weight) {
    // SglLep channels
    if (muons.size() == 1) {
        const Muon &mu = muons.at(0);
        const Particle METv = ev.GetMETVector();
        const double mT = MT(mu, METv);
        const double ptcorr = mu.Pt()*(1.+max(0, mu.MiniRelIso()-0.1));
        const double abseta = fabs(mu.Eta());
        const TString prefix = FindBin(ptcorr, abseta, ptcorr_edges);

    }
}
*/
TString MeasFakeRateV5::FindBin(double ptcorr, double abseta, double *ptcorr_edges, int nptcorr, double *abseta_edges, int nabseta) {
    ptcorr = max(10., min(ptcorr, 200.));
    int ptcorr_bin = -1;
    int eta_bin = -1;
    for (int i = 0; i < nptcorr; i++) {
        if (ptcorr_edges[i] <= ptcorr && ptcorr < ptcorr_edges[i+1]) {
            ptcorr_bin = i;
            break;
        }
    }
    for (int i = 0; i < neta; i++) {
        if (eta_edges[i] <= abseta && abseta < eta_edges[i+1]) {
            eta_bin = i;
            break;
        }
    }
    if (ptcorr_bin == -1 || eta_bin == -1) {
        cerr << "[MeasFakeRateV5::FindBin] No bin found for ptcorr = " << ptcorr << " and abseta = " << abseta << endl;
        exit(EXIT_FAILURE);
    }
    TString formattedString = TString::Format("ptCorr_%dto%d_abseta_%fto%f", 
                                              static_cast<int>(ptcorr_edges[ptcorr_bin]), 
                                              static_cast<int>(ptcorr_edges[ptcorr_bin+1]),
                                              eta_edges[eta_bin],
                                              eta_edges[eta_bin+1]);
    formattedString.ReplaceAll(".", "p");
    return formattedString;
}


